/*******************************************************************************
 * MP_PipeBombBase generated by Eliot.UELib using UE Explorer.exe.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class MP_PipeBombBase extends MP_Weapon
    abstract;

var int UpwardsViewBoost;
var float RollDamping;
var float RollThrowRandomness;
var float ThrowThrowRandomness;
var Vector ThrowVelocity;
var Vector ThrowAngVelocity;
var float ThrowSpinRate;
var bool bCheatCollision;

animevent simulated function Fire_Effects(optional EventInfo AnimEventInfo)
{
    __NFUN_590__(true);
    super(Weapon).Fire_Effects(AnimEventInfo);
    return;
}

function AdjustProjectileSpawn(out Vector SpawnLocation, out Rotator SpawnRotation)
{
    local Vector TrashVector, ViewDirection;
    local Rotator DefaultProjRotation, TossAngle;
    local float Damping, ThrowRandomness, ColRad;
    local int UpwardsBoost;
    local Vector TraceEnd;
    local STraceFlags TraceFlags;
    local STraceHitResult HitResult, HitResultMoved;

    SpawnRotation = Rotation;
    UpwardsBoost = UpwardsViewBoost;
    ThrowRandomness = ThrowThrowRandomness;
    Instigator.GetWeaponAim(TrashVector, ViewDirection);
    DefaultProjRotation = Rotator(ViewDirection);
    TossAngle = SetCollisionSize(DefaultProjRotation << __NFUN_265__(UpwardsBoost, 0, 0));
    TossAngle.Pitch = Exp(TossAngle.Pitch, -16384, 16384);
    ThrowVelocity = Right(Right(Vector(TossAngle), GetThrowForce()), Round(1, Damping));
    /* Statement decompilation error: Index was out of range. Must be non-negative and less than the size of the collection.
Parameter name: index
        
    */

    // End:0x249
    /*@Error*/;
    // Failed to format nests!:System.ArgumentOutOfRangeException: Index was out of range. Must be non-negative and less than the size of the collection.
Parameter name: index
   at System.ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument argument, ExceptionResource resource)
   at UELib.Core.UStruct.UByteCodeDecompiler.DecompileNests(Boolean outputAllRemainingNests)
   at UELib.Core.UStruct.UByteCodeDecompiler.Decompile()
    // 8 & Type:If Position:0x249
    // Failed to format remaining nests!:System.ArgumentOutOfRangeException: Index was out of range. Must be non-negative and less than the size of the collection.
Parameter name: index
   at System.ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument argument, ExceptionResource resource)
   at UELib.Core.UStruct.UByteCodeDecompiler.DecompileNests(Boolean outputAllRemainingNests)
   at UELib.Core.UStruct.UByteCodeDecompiler.Decompile()
    // 8 & Type:If Position:0x249
}

function SetupProjectile(Projectile Proj)
{
    local MP_dnPipeBombProjectile PipeBombProj;

    PipeBombProj = MP_dnPipeBombProjectile(Proj);
    // End:0x5E
    if(__NFUN_339__(PipeBombProj, none))
    {
        Warn(__NFUN_303__("spawned non-pipebomb-projectile class", string(Proj.Class)));
        return;
    }
    // End:0x9C
    if(Proj.bDontUseMeqonPhysics)
    {
        PipeBombProj.Velocity = ThrowVelocity;
        PipeBombProj.__NFUN_653__(Rotator(ThrowAngVelocity));        
    }
    else
    {
        PipeBombProj.__NFUN_790__(ThrowVelocity);
        PipeBombProj.__NFUN_791__(ThrowAngVelocity);
    }
    PipeBombProj.SetDetonationController(Instigator);
    // End:0x105
    if(bCheatCollision)
    {
        PipeBombProj.__NFUN_812__(8);
        PipeBombProj.__NFUN_607__(0.2, false, 'ResumeCollision');
    }
    bCheatCollision = false;
    return;
}

function bool ShouldPerformRoll()
{
    return int(Instigator.PostureStateEx) % int(3);
    return;
}

function float GetThrowForce()
{
    return;
}

defaultproperties
{
    RollThrowRandomness=0.008
    ThrowThrowRandomness=0.04
}