/*******************************************************************************
 * Electronics_Generic_DeskFan generated by Eliot.UELib using UELib.CLI.
 * Eliot.UELib Â© 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class Electronics_Generic_DeskFan extends Electronics_Generic
	collapsecategories;

enum EOscillateState
{
	OSC_Left,
	OSC_LeftPause,
	OSC_Right,
	OSC_RightPause
};

var() noexport bool bBladesBlowing "Absurd little detail. Set to false to make the blades spin in the opposite (sucking in) direction.";
var() noexport name HeadBone "Name of the bone to search for to control the oscillation.";
var() noexport float HeadTurnOnTime "How long it takes for the head to get up to full speed when turned on.";
var() noexport float HeadTurnOffTime "How long it takes for the head to come to a full stop when turned off.";
var() noexport float HeadTurnTime "How long it takes the head to perform a complete oscillation round.";
var() noexport float HeadPauseTime "How long to pause the head when it reaches the edge of an oscillation.";
var() noexport int HeadTurnLimit "Largest amount the head can turn away from center.";
var() noexport name BladeBone "Name of the bone to search for to control the blade spinning.";
var() noexport int BladeRateAccel "How fast the blade will spin up to full speed when turned on (units per second).";
var() noexport int BladeRateDecel "How fast the blade will spin down to 0 speed when turned off (units per second).";
var() noexport int BladeRateFull "How fast is considered full speed for the blade.";
var() noexport name TurnedOnEvent "Event to trigger when the fan is turned on.";
var() noexport name TurnedOffEvent "Event to trigger when the fan is turned on.";
var float HeadTimer;
var float HeadPauseTimer;
var float HeadScaler;
var float HeadPowerTimer;
var Rotator HeadPosition;
var Rotator BladeRate;
var Electronics_Generic_DeskFan.EOscillateState OscillationState;

event PostBeginPlay()
{
	TriggerFunc_PowerOn();
	super(dnDecoration).PostBeginPlay();
	return;
}

function bool VerifySelf()
{
	// End:0x51
	if(__NFUN_148__(__NFUN_339__(MeshInstance, none), __NFUN_339__(__NFUN_568__(), none)))
	{
		InvalidAlert(__NFUN_302__(__NFUN_302__("Error: ", string(self)), " does not have a MeshInstance."));
		return false;
	}
	HeadTurnTime = __NFUN_196__(__NFUN_211__(HeadTurnTime), 2);
	HeadTimer = __NFUN_195__(0.5, HeadTurnTime);
	return super(Actor).VerifySelf();
	return;
}

final function UpdateBlade(int amount, float DeltaSeconds)
{
	// End:0x12
	if(__NFUN_341__(BladeBone, 'None'))
	{
		return;
	}
	BladeRate.Roll = __NFUN_191__(int(__NFUN_198__(float(BladeRate.Roll), __NFUN_195__(float(amount), DeltaSeconds))), 0, BladeRateFull);
	// End:0x76
	if(bBladesBlowing)
	{
		MeshInstance.__NFUN_538__(BladeBone, __NFUN_266__(__NFUN_267__(float(-1), BladeRate), DeltaSeconds), false, true);		
	}
	else
	{
		MeshInstance.__NFUN_538__(BladeBone, __NFUN_266__(BladeRate, DeltaSeconds), false, true);
	}
	return;
}

final function UpdateHeadPosition(float DeltaSeconds)
{
	// End:0x12
	if(__NFUN_341__(HeadBone, 'None'))
	{
		return;
	}
	switch(OscillationState)
	{
		// End:0x1F
		case 1:
		// End:0x32
		case 3:
			PauseHeadPosition(DeltaSeconds);
			// End:0x4A
			break;
		// End:0x37
		case 0:
		// End:0x47
		case 2:
			MoveHeadPosition(DeltaSeconds);
		// End:0xFFFF
		default:
			break;
	}
	return;
}

final function PauseHeadPosition(float DeltaSeconds)
{
	HeadPauseTimer = __NFUN_227__(__NFUN_198__(HeadPauseTimer, DeltaSeconds), 0, HeadPauseTime);
	// End:0x63
	if(__NFUN_203__(HeadPauseTimer, HeadPauseTime))
	{
		HeadPauseTimer = 0;
		switch(OscillationState)
		{
			// End:0x50
			case 1:
				OscillationState = 2;
				// End:0x63
				break;
			// End:0x60
			case 3:
				OscillationState = 0;
				// End:0x63
				break;
			// End:0xFFFF
			default:
				break;
		}
	}
	else
	{
		return;
	}
}

final function MoveHeadPosition(float DeltaSeconds)
{
	__NFUN_207__(DeltaSeconds, HeadScaler);
	// End:0x1D
	if(__NFUN_202__(DeltaSeconds, 0))
	{
		return;
	}
	HeadTimer = __NFUN_227__(__NFUN_198__(HeadTimer, DeltaSeconds), 0, HeadTurnTime);
	switch(OscillationState)
	{
		// End:0x73
		case 0:
			HeadPosition.Yaw = int(__NFUN_229__(__NFUN_196__(HeadTimer, HeadTurnTime), float(HeadTurnLimit), float(__NFUN_161__(HeadTurnLimit))));
			// End:0xA6
			break;
		// End:0xA3
		case 2:
			HeadPosition.Yaw = int(__NFUN_229__(__NFUN_196__(HeadTimer, HeadTurnTime), float(__NFUN_161__(HeadTurnLimit)), float(HeadTurnLimit)));
			// End:0xA6
			break;
		// End:0xFFFF
		default:
			break;
	}
	// End:0xEB
	if(__NFUN_203__(HeadTimer, HeadTurnTime))
	{
		HeadTimer = 0;
		switch(OscillationState)
		{
			// End:0xD8
			case 0:
				OscillationState = 1;
				// End:0xEB
				break;
			// End:0xE8
			case 2:
				OscillationState = 3;
				// End:0xEB
				break;
			// End:0xFFFF
			default:
				break;
		}
	}
	else
	{
		return;
	}
}

simulated event bool OnEvalBonesHelper()
{
	// End:0x24
	if(__NFUN_145__(DecorationIsDead()))
	{
		MeshInstance.__NFUN_538__(HeadBone, HeadPosition, false, false);
	}
	return true;
	return;
}

function Destroyed()
{
	super(dnDecoration).Destroyed();
	__NFUN_397__('None');
	bNoNativeTick = true;
	return;
}

function ForcePowerOn()
{
	super.ForcePowerOn();
	HeadPowerTimer = 0;
	DecoActivity(0, 'TurnOn');
	GlobalTrigger(TurnedOnEvent,, self);
	__NFUN_397__('TurnedOn');
	return;
}

function ForcePowerOff()
{
	super.ForcePowerOff();
	HeadPowerTimer = 0;
	DecoActivity(0, 'TurnOff');
	GlobalTrigger(TurnedOffEvent,, self);
	__NFUN_397__('TurnedOff');
	return;
}

simulated function bool CanBeUsedBy(Pawn User)
{
	// End:0x20
	if(__NFUN_148__(super(InteractiveActor).CanBeUsedBy(User), __NFUN_145__(bEMPulsed)))
	{
		return true;		
	}
	else
	{
		return false;
	}
	return;
}

state TurnedOn
{
	event Used(Actor Other, Pawn EventInstigator)
	{
		global.Used(Other, EventInstigator);
		TriggerFunc_PowerOff();
		return;
	}

	function HitByEMP(optional float Duration, optional Pawn Instigator)
	{
		global.HitByEMP(Duration, Instigator);
		// End:0x21
		if(bEMPulsed)
		{
			bPoweredBeforeEMP = true;
		}
		return;
	}

	event Tick(float DeltaSeconds)
	{
		global.Tick(DeltaSeconds);
		// End:0x56
		if(__NFUN_200__(HeadScaler, 1))
		{
			HeadPowerTimer = __NFUN_227__(__NFUN_198__(HeadPowerTimer, DeltaSeconds), 0, HeadTurnOnTime);
			HeadScaler = __NFUN_228__(__NFUN_196__(HeadPowerTimer, HeadTurnOnTime), 0, 1);
		}
		UpdateBlade(BladeRateAccel, DeltaSeconds);
		UpdateHeadPosition(DeltaSeconds);
		return;
	}
	stop;
}

state TurnedOff
{
	event Used(Actor Other, Pawn EventInstigator)
	{
		global.Used(Other, EventInstigator);
		// End:0x21
		if(__NFUN_145__(bEMPulsed))
		{
			TriggerFunc_PowerOn();
		}
		return;
	}

	final function bool FanStillMoving()
	{
		return __NFUN_150__(__NFUN_201__(HeadScaler, 0), __NFUN_170__(BladeRate.Roll, 0));
		return;
	}

	event Tick(float DeltaSeconds)
	{
		global.Tick(DeltaSeconds);
		// End:0x61
		if(__NFUN_201__(HeadScaler, 0))
		{
			HeadPowerTimer = __NFUN_227__(__NFUN_198__(HeadPowerTimer, DeltaSeconds), 0, HeadTurnOffTime);
			HeadScaler = __NFUN_228__(__NFUN_196__(HeadPowerTimer, HeadTurnOffTime), 1, 0);
			UpdateHeadPosition(DeltaSeconds);
		}
		// End:0x81
		if(__NFUN_170__(BladeRate.Roll, 0))
		{
			UpdateBlade(BladeRateDecel, DeltaSeconds);
		}
		// End:0x94
		if(__NFUN_145__(FanStillMoving()))
		{
			TickStyle = 0;
		}
		return;
	}
	stop;
}

defaultproperties
{
	bBladesBlowing=true
	HeadBone=Head
	HeadTurnOnTime=1.5
	HeadTurnOffTime=4
	HeadTurnTime=8
	HeadPauseTime=0.75
	HeadTurnLimit=11264
	BladeBone=Blades
	BladeRateAccel=131072
	BladeRateDecel=-65536
	BladeRateFull=262144
	DecoActivities_Default=/* Array type was not detected. */
}